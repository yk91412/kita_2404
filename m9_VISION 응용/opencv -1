
*** OpenCV에서 이미지 배열이 높이(세로), 너비(가로), 채널 순서 ***

===========================================================================


### cv2.compareHist() 함수

OpenCV에서 히스토그램을 비교하는 함수

두 이미지의 히스토그램을 비교하여 얼마나 유사한지 또는 다른지를 수치적으로 나타냅니다
이 함수는 여러 가지 비교 방법을 제공하며, 그 중 하나가 상관계수(Correlation) 방식

=> 이 값은 -1에서 1 사이의 값을 가집니다:

1에 가까울수록 두 히스토그램이 매우 유사
0에 가까울수록 두 히스토그램이 관련이 없음을 의미
-1에 가까울수록 두 히스토그램은 완전히 반대의 경향

### cv2.calcHist() 함수

cv2.calcHist(images, channels, maskm histSize, ranges, hist=None, accumulate=None) -> hist

images: 입력 영상 리스트
channels: 히스토그램을 구할 채널을 나타내는 리스트
mask: 마스크 영상. 입력 영상 전체에서 히스토그램을 구하려면 None 지정
histSize: 히스토그램 각 차원의 크기(빈(bin)의 개수)를 나타내는 리스트
ranges: 히스토그램 각 차원의 최솟값과 최댓값으로 구성된 리스트
hist: 계산된 히스토그램 (numpy.ndarray)
accumulate: 기존의 hist 히스토그램에 누적하려면 True, 새로 만들려면 False

===========================================================================


### comparehist vs calchist

**calcHist**를 사용하여 이미지의 히스토그램을 생성
이 단계에서는 이미지의 픽셀 값 분포를 계산하고, 그 결과로 히스토그램을 만듭니다.

생성된 히스토그램을 **compareHist**에 전달하여 두 히스토그램 간의 유사성을 비교
이 함수는 여러 가지 방법으로 두 히스토그램의 유사도를 평가할 수 있습니다.

즉, calcHist로 히스토그램을 만들고, 그 히스토그램을 compareHist로 비교하는 방식으로 작업하는 것이죠!


===========================================================================

### cv2.resize

cv2 resize의 파라미터
(이미지,(직접 지정할 크기), fx=현재 이미지 가로의 몇배, fy, = 현재 이미지 세로의 몇배, 보간법) 으로 구성

cv2.INTER_CUBIC : 바이큐빅 보간법 - when : 사이즈를 늘릴 때 (LINEAR보다 속도가 느리거나 정밀한 결과 제공)
cv2.INTER_LINEAR : 쌍선형 보간법 - when : 사이즈를 늘릴 때(default, 속도가 중요한 경우 선호)
cv2.INTER_AREA : 영역 보간법 - when : 사이즈를 줄일 때

- INTER_CUBIC을 사용하여 크기 조정
  -> 쌍 선형보다 느리지만 성능이 더 우수, 확대 시 주로 사용, 16개의 픽세 이용
resized_image_cubic = cv2.resize(image, dsize=(640,400), interpolation=cv2.INTER_CUBIC)


- INTER_LINEAR를 사용하여 크기 조정
  -> 효율이 뛰어남. 속도와 성능 준수. 확대 시 주로 사용. 4개의 픽셀 이용
  ->dsize=(0,0) : 새로운 이미지의 크기를 명시적으로 지정하지 않는 경우 (0,0)로 설정합니다. 이 경우 , fx, fy값에 따라 이미지 크기가 결정
resized_image_linear = cv2.resize(image, dsize=(0,0), fx=1.5,fy=1.5, interpolation=cv2.INTER_LINEAR)


===========================================================================


### 이미지 임계처리


기본 임계처리 이진화란 영상을 흑/백으로 분류하여 처리하는 것
이때 기준이 되는 임계값을 어떻게 결정할 것인지가 중요한 문제
** 임계값보다 크면 백, 작으면 흑
기본 임계처리는 사용자가 고정된 임계값을 결정하고 그 결과를 보여주는 단순한 형태임


=> Parameters:
src – input image로 single-channel 이미지.(grayscale 이미지)
thresh – 임계값
maxval – 임계값을 넘었을 때 적용할 value
type – thresholding type


ex)
* 픽셀값이 127보다 크면(즉, 128이상이면) 지정한 최댓값(127)으로 설정되고, 127이하이면 0으로 설정
_, bin_image = cv2.threshold(gray_image,127,127,cv2.THRESH_BINARY)


* cv2의 threshold 메서드에 흑백 이미지, 기준값과 원하는 값, cv2.THRES_BINARY 옵션을 전달하면 이진화를 지정
* 픽셀 값이 임계값(127)보다 클 때는 주어진 최댓 값을 (여기서는 255), 그렇지 않을 때는 0을 적용
_, bin_image = cv2.threshold(gray_image, 127,255,cv2.THRESH_BINARY)


** threshold 메서드의 마지막 인자 cv2.THRESH_BINARY_INV를 전달하면 이진화 역 변환
_, bin_inv_image = cv2.threshold(gray_image, 127,255,cv2.THRESH_BINARY_INV)

=>> 이미지를 이진화하는 주된 이유
이미지의 단순화를 통해 중요한 정보를 추출하거나 처리를 용이하게 하기 위해서

=> 이미지 단순화, 객체 검출, 컴퓨터 비전 알고리즘 간소화, 이미지 분할(세그멘테이션)
경계선 추출, 노이즈 제거, 특징 인식 등 다양한 이미지 처리 및 분석 작업에서 유용하게 사용


ex) 

문자 인식(OCR) :
문서를 스캔하여 텍스트를 감지하는 과정에서 배경과 문자를 분리하여
문자의 윤곽을 뚜렷하게 만들어 인식 성능을 향상

의료 영상 처리 :
X-ray나 MRI 이미지에서 특정 병변을 감지할 때 이진화를 사용하여 병변과 정상 조직을 구분

산업용 검사 :
제조 공정에서 제품의 결함 검사나 크기 측정에 이진화를 적용하여 표면의 흠집이나 불량품을 탐지

도로 감시 시스템 :
차량의 번호판 인식과 같은 작업에서도 배경과 번호판을 구분하기 위해 이진화를 사용


===========================================================================


AND 연산:

cv2.bitwise_and: 두 이미지의 비트값을 AND 연산합니다.
결과: 두 이미지에서 모두 흰색인 부분만 흰색으로 나타납니다. 그 외의 영역은 검은색으로 처리됩니다.
OR 연산:

cv2.bitwise_or: 두 이미지의 비트값을 OR 연산합니다.
결과: 두 이미지 중 하나라도 흰색인 부분은 흰색으로 표시됩니다. 즉, 하나의 이미지에서만 흰색이더라도 그 부분이 흰색으로 나타납니다.
NOT 연산:

cv2.bitwise_not: 하나의 이미지에 대해 비트 NOT 연산을 수행합니다.
결과: 이미지의 모든 픽셀 값이 반전됩니다. 흰색은 검은색으로, 검은색은 흰색으로 바뀝니다.
XOR 연산:

cv2.bitwise_xor: 두 이미지의 비트값을 XOR 연산합니다.
결과: 두 이미지의 비트 값이 서로 다른 경우 흰색, 서로 같은 경우 검은색으로 표시됩니다.

ex) img_and = cv2.bitwise_and(img1_resized,img2)


===========================================================================

이미지 ROI

이미지 작업시에는 특정 pixel단위 보다는 특정 영역단위로 작업을 하게 되는데 이것을 Region of Image(ROI)라고 함
ROI 설정은 Numpy의 indexing을 사용 , 특정 영역을 copy할 수도 있음
