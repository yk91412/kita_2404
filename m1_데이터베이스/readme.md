
- distinct 중복 제거
- 
  ex) select distinct publisher from book
  
- like 정확히 일치하는 행만 선택
- 
  %활용 => %구% 구가 어디에나 포함되어 있는지
  
  ex) select * from book
      where bookname like '_구%'

      => 앞에 아무 한글자+구+아무 글자(없어도 가능)

  ====================================================
  
- join
  
   ** 내부조인
  
      inner join : 교집합
  
   ** 외부 조인 : 일치하는게 없다면 null

      left outer join
      right outer join
      full outer join

    ** cross join : 모든 가능한 조합 생성


   ====================================================

 * 데이터 타입
  
1. 숫자형 (Numeric Types)

--NUMBER: 가장 범용적인 숫자 데이터 타입. 정수, 실수, 고정 소수점, 부동 소수점 수를 저장

     number(39,0) 39: 자릿수, 0 : 소수점 /소수점 포함한 자릿수

2. 문자형 (Character Types)

--VARCHAR2(size): 가변 길이 문자열을 저장. size는 최대 문자 길이를 바이트로 지정

*** varchar2 char인지 byte인지 확인법

SELECT *
    FROM NLS_SESSION_PARAMETERS
    WHERE PARAMETER = 'NLS_LENGTH_SEMANTICS'

--NVARCHAR2(size)의 사이즈를 지정할 때는 바이트 단위 대신 항상 문자 단위로 크기가 지정

--CHAR(size): 고정 길이 문자열을 저장. 지정된 길이보다 짧은 문자열이 입력되면 나머지는 공백으로 채워짐

3. 날짜 및 시간형 (Date and Time Types)
  
--DATE 타입은 날짜와 시간을 YYYY-MM-DD HH24:MI:SS 형식으로 저장
  
--DATE: 날짜와 시간을 저장. 데이터 타입은 년, 월, 일, 시, 분, 초를 포함

--TIMESTAMP: 날짜와 시간을 더 상세히 나노초 단위까지 저장

--이진 데이터형 (Binary Data Types)

--BLOB: 대량의 이진 데이터를 저장. 이미지, 오디오 파일 등을 저장하는 데 적합

--대규모 객체형 (Large Object Types)

--CLOB: 대량의 문자 데이터를 저장(텍스트)

--NCLOB: 대량의 국가별 문자 집합 데이터를 저장

   ====================================================
   
* 제약조건
  
--PRIMARY KEY : 각 행을 고유하게 식별하는 열(또는 열들의 조합)

 중복되거나 NULL 값을 허용X

--FOREIGN KEY : 다른 테이블의 기본 키를 참조하는 열. 참조 무결성을 유지

    foreign key(참조하는 컬럼명) references 참조 테이블(참조 컬럼명)

--UNIQUE : 열에 중복된 값이 없어야 함을 지정. NULL값이 허용

--NOT NULL : 열에 NULL 값을 허용하지 않는다.

--CHECK : 열 값이 특정 조건을 만족해야 함을 지정 (예: age > 18)

--DEFAULT : 열에 명시적인 값이 제공되지 않을 경우 사용될 기본값을 지정

-- on delete cascade 참조하고 있는 테이블이 삭제되면 같이 삭제됨
   
   ====================================================

   - 테이블 제약 조건 수정, 추가, 삭제

      alter table 테이블명 modify 컬럼명 바꿀타입

      alter table 테이블명 add 추가할 컬럼명 추가할타입

      alter table 테이블명 drop column 컬럼명

    - 제약조건 변경
      
    -- ALTER TABLE {테이블명} ADD CONSTRAINT {제약조건명} {제약조건}

    -- alter table 테이블명 modify (컬럼명 제약조건)
       

     * desc 테이블명

         테이블에서 컬럼명과 조건이 나온다

         ex) name varchar2(20)
             id number...

       
    - update 테이블명 set 바꾸고싶은 내용
       where (조건을 원한다면/생략시 모든 컬럼이 포함)
   
  ====================================================

  -- 원하는 데이터만 삭제하기

    -- ex)
    delete animal
    where animalid = 1;

  * 절댓값 abs

  * 반올림 round : -2이면 십의 자리에서 반올림

  * 올림 ceil : 자리 지정x

  * 버림 trunc : 지정한 자리수 이하 버림

  * mod 나머지 => 활용하여 id가 홀수인 사람을 구할 수 있다

      ex) ~~ where mod(~id,2) = 1 => 2로 나눴을 때 나머지 1

  * length 글자수

  * lenghtb 바이트 수

  * 오라클에서는 문자열을 date로 자동 변환하여 비교한다

  * 데이터 타입이나 문자열 변환시 yy-mm-dd or yy/mm/dd 원하는 형식으로 출력가능

  * || ' ' ||을 사용하여 두 컬럼을 연결할 수 있다

  * in : or 대신 사용 / 더 간단히 표현할 수 있다

  * _을 와일드 카드가 아닌 문자로 취급하고 싶을 때 escape 옵션 사용

      ex) select * from employees where job_id like '%\_A%' escape '\'

        =>  _A인 id를 찾고싶을 때
      
  * is null / is not null

  * 새로운 열을 만들어서 원하는 값으로 넣고 싶을 때

      ex) '신입' position

        => position이라는 열을 추가하여 '신입'이라는 값을 넣겠다
    
 ====================================================

   ** 순위 함수

    * rownum 임의 순위 원하는 순위만 출력

    * rank() over

    중복값이 발생되면 중복 값의 갯수만큼 건너 뛰고 다음 순위 부여

      ex) 90,80,80,70 => 1,2,2,4

    RANK() OVER(ORDER BY 컬럼명 (ASC|DESC)) (AS 별칭)

    * dense_rank() over

      중복순위 발생시 다음 순위를 연속된 값을 부여

      ex) 90,80,80,70 => 1,2,2,3...

    * row_number() over

      중복값에 관계없이 순차적인 순위 값을 반환

      ex) 90,80,80 => 1,2,3
      
   ====================================================
  
   ** 함수
   
    * replace(컬럼명 or 문자열, 찾을 문자, 치환 문자)

    제거를 원할 땐 치환문자 생략

    * substr(컬럼명 or 문자열, 시작위치, 길이(개수))
    
        : 길이 생략시 시작부터 끝까지

    * instr(문자열, 찾을 문자, 시작 위치, 찾은 문자중 몇번째에 있는지(생략))

        : 마지막 생략시 시작위치에서 첫번째로 발견한 위치 반환

          인덱스 1부터 시작

    * add_months(date타입 컬럼명,더하고싶은 개월수)

    * last_day() 해당 월의 마지막 날짜를 반환하는 함수

    * next_day() 해당 날짜를 기준으로 다음에 오는 요일에 해당하는 날짜 반환

        일~토, 1~7로 표현가능

    * months_between() 날짜와 날짜 사이의 개월수를 구한다
    
    * 형변환 함수

    1. to_date() 문자열을 날짜로 변환

    2. to_char() 날짜를 문자로 변환
    --형식
    
          --YYYY       네 자리 연도
          --YY      두 자리 연도
          --YEAR      연도 영문 표기
           --MM      월을 숫자로
          --MON      월을 알파벳으로
          --DD      일을 숫자로
          --DAY      요일 표현
          --DY      요일 약어 표현
          --D      요일 숫자 표현
          --AM 또는 PM   오전 오후
          --HH 또는 HH12   12시간
          --HH24      24시간
          --MI      분
          --SS      초

    * 문자 함수

    upper() 대문자로 변경

    lower() 소문자로 변경

    initcap() 첫글자만 대문자로 변경

    * 분할 함수
      
      width_bucket() 지정값, 최솟값, 최댓값, bucket 개수

      : 최댓값은 포함안하고 -1값까지 포함함

      ex) 0,100,5라면

      첫 번째 버킷: 0부터 19
      
      두 번째 버킷: 20부터 39
      
      세 번째 버킷: 40부터 59
      
      네 번째 버킷: 60부터 79
      
      다섯 번째 버킷: 80부터 99

    * pad() 함수

     1.  lpad() 오른쪽 정렬 후 왼쪽에 문자를 채운다

          ex) lpad(문자열 or 컬럼명, 원하는 길이, 채우고 싶은 문자)

              => 왼쪽에 채우고 싶은 문자가 채워진다
              
     2.  rpad() 왼쪽 정렬 후 오른쪽에 문자를 채운다

    * trim() 함수

       1. ltrim(문자열, 문자열에서 삭제하고싶은 문자)

        ex) ltrim('aaaHello Worldaaa','a')

          => 왼쪽에서 a가 없어진다

       2. rtrim() : 오른쪽

       3. trim() : 양쪽 다

      ** (지우고 싶은 문자 from 컬럼명 or 문자열) 이런식으로 표현 가능

    * NVL함수

      (컬럼명, null일 때 치환값) : null이 아니면 컬럼에 있는 값 출력


    * decode() : 여러 경우를 선택할 수 있는 함수

      decode(검사할 값, 조건, 조건이 참일 때 반환, 모두 거짓일 때 반환할 기본값)

      ex) select decode(department_id, 90, '경영 지원실','기타') 부서

        => 부서라는 컬럼이 생성되어 90이면 경영 지원실 아니면 기타로 출력
        
    * case() : 다양한 비교연산자로 조건 제시할 수 있는 함수

      ex) select department_id
      case when department_id = 90 then '경영 지원실'
            when ~ 60 then ~
            else '기타'
            end as 소속

        => 소속이라는 컬럼이 생성되어 90이면 경영 지원실 ~~

          아니면 기타로 생성
          
   ====================================================

    * 집합 연산자

    join과 차이점 : 집합은 행의 집합을 조작하고 결합하는 데 사용되지만

        조인은 여러 테이블을 결합하고 관계를 형성할 때 사용

    UNION(합집합) INTERSECT (교집합) MINUS (차집합) UNION ALL (겹치는 것까지 포함)

    데이터 타입이 일치해야한다


   ====================================================

   뷰(VIEW)

   테이블의 특정 부분이나 조인된 결과를 뷰로 만들 때 사용

   데이터를 요약하거나 복잡한 조인을 단순화하여 필요한 데이터만 보여줄 때 유용

   특징:

   1. 쿼리 단순화

   2. 데이터 추상화 : 필요한 데이터만을 보여줄 수 있음

   3. 보안 강화 : 특정 데이터에 대한 접근 제한 가능

   4. 데이터 무결성 유지 : 수정하더라도 변경사항이 기본 테이블에 영향 x

    ex) create table 만들 테이블명 as
      select 추출하고 싶은 컬럼명
      from 기존 테이블명
      where (원하는 조건이 있을 때)
  
   ====================================================

     --to_char( 숫자 )   숫자를 문자로 변환
      --9      한 자리의 숫자 표현      ( 1111, ‘99999’ )      1111   
      --0      앞 부분을 0으로 표현      ( 1111, ‘099999’ )      001111
      --$      달러 기호를 앞에 표현      ( 1111, ‘$99999’ )      $1111
      --.      소수점을 표시         ( 1111, ‘99999.99’ )      1111.00
      --,      특정 위치에 , 표시      ( 1111, ‘99,999’ )      1,111
      --MI      오른쪽에 - 기호 표시      ( 1111, ‘99999MI’ )      1111-
      --PR      음수값을 <>로 표현      ( -1111, ‘99999PR’ )      <1111>
      --EEEE      과학적 표현         ( 1111, ‘99.99EEEE’ )      1.11E+03
      --V      10을 n승 곱한값으로 표현   ( 1111, ‘999V99’ )      111100
      --B      공백을 0으로 표현      ( 1111, ‘B9999.99’ )      1111.00
    --L      지역통화         ( 1111, ‘L9999’ )

    --과학적 표기법*/ MI / 0은 알아두는게 좋다
    
      select to_char(11111,'9.999eeee') from dual;

       => 1.111E+04

   ====================================================
   
--문자 인코딩의 의미

--컴퓨터는 숫자로 이루어진 데이터를 처리. 인코딩을 통해 문자(예: 'A', '가', '?')를 

--숫자(코드 포인트)로 변환하여 컴퓨터가 이해하고 저장할 수 있게 한다.

--예를 들어, ASCII 인코딩에서는 대문자 'A'를 65로, 소문자 'a'를 97로 인코딩. 

--유니코드 인코딩에서는 'A'를 U+0041, 한글 '가'를 U+AC00, 이모티콘 '?'를 U+1F60A로 인코딩

--아스키는 7비트를 사용하여 총 128개의 문자를 표현하는 반면 유니코드는 최대 1,114,112개의 문자를 표현

--ASCII 인코딩:

--문자 'A' -> 65 (10진수) -> 01000001 (2진수)

--문자 'B' -> 66 (10진수) -> 01000010 (2진수)

--유니코드(UTF-8) 인코딩: 

--문자 'A' -> U+0041 -> 41 (16진수) -> 01000001 (2진수, ASCII와 동일)

--문자 '가' -> U+AC00 -> EC 95 80 (16진수) -> 11101100 10010101 10000000 (2진수)

--CLOB: CLOB은 일반적으로 데이터베이스의 기본 문자 집합(예: ASCII, LATIN1 등)을 사용하여 텍스트 데이터를 저장. 

--이 때문에 주로 영어와 같은 단일 바이트 문자로 이루어진 텍스트를 저장하는 데 사용.

--NCLOB: NCLOB은 유니코드(UTF-16)를 사용하여 텍스트 데이터를 저장. 따라서 다국어 지원이 필요할 때, \

--즉 다양한 언어로 구성된 텍스트 데이터를 저장할 때 적합. 다국어 문자가 포함된 데이터를 효율적으로 처리할 수 있다.
